from datetime import datetime, timezone
from typing import Optional, Union, Any, Literal, Dict, List, Set
from pydantic import (
    BaseModel,
    Field,
    ValidationError,
    field_validator,
    model_validator,
    AliasChoices,
)

import uuid

from datetime import datetime

import logging

log = logging.getLogger(__name__)


class QueueStatusResponse(BaseModel):
    """
    ## Ingress API route response packet.

    This packet returns the status of the message in plaintext, and informs the user of the queue number (or how many other messages of the same type (LoRa, Iridium, APRS, etc) are in the queue ahead of it).

    In Iridium and APRS routes, if the data or raw_data field was not JSON but rather a hex string (for Iridium) and an APRS packet string (for APRS), the decode_success field will inform the user of if the server could successfully decode this data, or if it is malformed.
    """
    status: str = "queued"
    queue_number: int
    # Optional fields that might vary
    decode_success: bool | None = None


class IridiumMessage(BaseModel):
    """
    ## Iridium message JSON packet as sent directly from the Iridium satellite network through GroundControl's Rock7 API.

    3rd parties are unable to send messages to this route, as they must be signed by Rock7's private key.

    The data packet here is a hex string from the Rock7 API, but the contents of the message conform to the same format as the LoRa raw_data field.
    """

    momsn: int = Field(..., description="Message ID")
    imei: str = Field(..., description="IMEI of the device")
    data: str = Field(..., description="Message data as a hex string")
    serial: int = Field(..., description="Serial number of the device")
    device_type: str = Field(..., description="Type of device")
    iridium_latitude: float = Field(..., description="Latitude in degrees")
    iridium_longitude: float = Field(..., description="Longitude in degrees")
    iridium_cep: float = Field(..., description="CEP in meters")
    transmit_time: datetime = Field(
        ..., description="Transmit time like 25-03-26 23:45:44 (YY-MM-DD HH:MM:SS)"
    )
    JWT: str = Field(..., description="JWT token for authentication")

    @field_validator("transmit_time", mode="before")
    @classmethod
    def validate_transmit_time(cls, value: Any) -> datetime:
        """
        Iridium sends us the transmit time in a specific format (YY-MM-DD HH:MM:SS), which we can't change
        So, let's fix it ourselves here
        """
        if isinstance(value, str):
            try:
                # Convert the string to a datetime object
                return datetime.strptime(value, "%y-%m-%d %H:%M:%S").replace(
                    tzinfo=timezone.utc
                )
            except ValueError as e:
                log.error(f"Invalid transmit_time format: {value}. Error: {e}")
                raise e
        elif isinstance(value, datetime):
            # If it's already a datetime object, just return it
            return value
        else:
            raise ValueError(
                f"Invalid transmit_time type: {type(value)}. Expected str or datetime."
            )


class APRSMessage(BaseModel):
    """
    ## APRS message JSON packet.
    Includes a mandatory raw_data field, which is the raw data received from the APRS receiver, usually as a string.

    Messages must also send a current timestamp in UTC or with timezone info.
    Optionally, a message_id (or unique uuid) generated for the received APRS packet can be included to help ease the server's message de-duplication when multiple HTTP packets are received for the same message in spotty internet scenarios.

    To claim credit for the message without modifying the raw_data, the sender field can be used to identify the device that relayed the message to us. This could be a callsign w/ optional SSID, or really anything. It will default to your IP address if unspecified.
    """

    message_id: uuid.UUID | None = Field(
        None,
        description="Message ID, new for each message to prevent duplicates. This is generated by the APRS receiver if it is not included in the raw data.",
    )
    sender: str | None = Field(
        None,
        description="ID of device that relayed message to us. Defaults to IP address for HTTP events, client ID for MQTT events, and nothing for APRS events."
    )
    raw_data: str | dict = Field(
        ...,
        description="Raw APRS message. This is the raw data received from the APRS receiver.",
        examples=["KF8ABL-11>APRS,WIDE2-1:!4217.67N/08342.78WO010/005100 ft"]
    )
    timestamp: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        description="Timestamp of the message. Should be as close to the original timestamp as possible. If not included, the server will use the time of endpoint reception.",
    )


class LoRaMessage(BaseModel):
    """
    ## LoRa message JSON packet.
    The actual received JSON LoRa packet by a LoRa receiver (the same JSON packet format as Iridium uses) is wrapped into the raw_data field so that supplementary information can be included.

    The message_id field is a unique identifier (uuid) that a ground station could generate and attach to an incoming packet in order to ease de-duplication load on the server if multiple HTTP packets are received for the same message in spotty internet scenarios.

    The sender field is the ID of the device that relayed the message to us. This could be a callsign w/ optional SSID, or really anything. It will default to your IP address if unspecified.

    The timestamp field is the time of the message. It should be as close to the original timestamp as possible. If not included, the server will use the time of endpoint reception.
    """

    message_id: Optional[uuid.UUID] = Field(
        None,
        description="Message ID, new for each message to prevent duplicates. This is generated by the LoRa receiver if it is not included in the raw data.",
    )
    sender: Optional[str] = Field(
        None,
        description="Recipient of the original LoRa message and the device making this POST to the server. Can be callsign or other, auto-generated as IP if not included.",
    )
    raw_data: Union[dict, str, bytes] = Field(
        ...,
        description="Raw data of the LoRa message. This is the raw data received from the LoRa receiver.",
    )
    timestamp: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        description="Timestamp of the message. Should be as close to the original timestamp as possible. If not included, the server will use the time of endpoint reception.",
    )


class Bbox(BaseModel):
    minLat: float
    minLon: float
    maxLat: float
    maxLon: float


class InitialDataRequest(BaseModel):
    bbox: Bbox
    history_seconds: int = Field(
        default=10800,  # Default to 3 hours (3 * 60 * 60)
        gt=0,  # Ensure positive value
        le=86400,  # Limit to 24 hours (24 * 60 * 60)
        description="How far back to fetch historical data, in seconds.",
    )


class UpdateViewportRequest(BaseModel):
    bbox: Bbox


class PointData(BaseModel):
    """Represents a single point in a payload's path."""

    lat: float
    lon: float
    ts: str = Field(
        ..., description="ISO 8601 timestamp (UTC) of the data point (data_time)"
    )


class PathData(BaseModel):
    """Represents the recent path of a single payload."""

    payload_id: int = Field(..., description="Corresponds to payloads.id")
    path_points: List[PointData]


class PositionUpdateData(BaseModel):
    """Data structure for broadcasting real-time position updates."""

    payload_id: int  # Corresponds to payloads.id
    lat: float
    lon: float
    timestamp: str  # ISO 8601 timestamp (UTC) of the data point (data_time)
    # Optional: Include other minimal data if needed for immediate display
    # altitude: Optional[float] = None
    # speed: Optional[float] = None
    # course: Optional[float] = None


class TelemetryRequest(BaseModel):
    """Request structure for fetching detailed telemetry."""

    payloadId: int = Field(..., description="Corresponds to payloads.id")
    timestamp: str = Field(
        ...,
        description="ISO 8601 timestamp (UTC) of the specific data point (data_time)",
    )


class TelemetryData(BaseModel):
    """Detailed telemetry data for a specific point in time. Matches 'telemetry' table columns."""

    # Include fields directly from the 'telemetry' table that you want to expose
    altitude: Optional[float] = None
    speed: Optional[float] = None
    course: Optional[float] = None
    battery: Optional[float] = None
    accuracy: Optional[float] = None  # Position accuracy in meters
    extra: Optional[Dict[str, Any]] = {}  # For the jsonb column


class GeoJsonProperties(BaseModel):
    payload_id: int
    # Add any other properties you want associated with the segment
    # e.g., start_time: str, end_time: str


class GeoJsonGeometry(BaseModel):
    type: str = "LineString"
    coordinates: List[List[float]]  # List of [lon, lat] pairs


class GeoJsonFeature(BaseModel):
    type: str = "Feature"
    properties: GeoJsonProperties
    geometry: GeoJsonGeometry


class GeoJsonFeatureCollection(BaseModel):
    type: str = "FeatureCollection"
    features: List[GeoJsonFeature]


# Structure for WebSocket messages (internal representation)
class WebSocketMessage(BaseModel):
    type: str
    payload: Optional[Dict[str, Any]] = None
    request_id: Optional[str] = None  # For tracking requests/responses


# Structure for messages sent TO client via WebSocket
class WebSocketResponse(BaseModel):
    type: str  # e.g., 'initialData', 'catchUpData', 'newPosition', 'telemetryResponse', 'error'
    request_id: Optional[str] = None  # Correlate response to request if needed
    data: Optional[Any] = None
    error: Optional[str] = None
