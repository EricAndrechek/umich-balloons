bridge_username = "bridge_username";
bridge_password = "bridge_password";

/**
 * Takes a CALLSIGN string and returns a passcode number.
 * This is a JavaScript translation of the standard APRS passcode algorithm.
 * @param {string} callsign - The input callsign string (e.g., "N0CALL", "N0CALL-9").
 * @returns {number} The calculated passcode (an integer between 0 and 32767).
 * @throws {TypeError} If the input is not a string.
 */
function passcode(callsign) {
    // Ensure input is a string (similar to Python's assert isinstance)
    if (typeof callsign !== "string") {
        throw new TypeError("Input callsign must be a string.");
    }

    // Take only the base callsign (before any '-') and convert to uppercase.
    // Equivalent to: callsign = callsign.split("-")[0].upper()
    baseCallsign = callsign.split("-")[0].toUpperCase();

    // Initialize the code with the seed value 0x73E2
    // Equivalent to: code = 0x73E2
    code = 0x73e2;

    // Loop through the characters of the base callsign
    // Equivalent to: for i, char in enumerate(callsign):
    for (i = 0; i < baseCallsign.length; i += 2) {
        // Process two characters at a time if possible
        char1 = baseCallsign[i];
        // Get ASCII/Unicode value. Equivalent to: ord(char1)
        charCode1 = char1.charCodeAt(0);
        // Left shift by 8. Equivalent to: ord(char1) << 8
        code ^= charCode1 << 8;

        // Check if there's a second character in the pair
        if (i + 1 < baseCallsign.length) {
            char2 = baseCallsign[i + 1];
            // Get ASCII/Unicode value. Equivalent to: ord(char2)
            charCode2 = char2.charCodeAt(0);
            // No shift (or shift by 0). Equivalent to: ord(char2) << 0
            code ^= charCode2;
        }
    }

    // Mask the result with 0x7FFF to ensure it's a positive 15-bit value
    // Equivalent to: return code & 0x7FFF
    return code & 0x7fff;
}

function checkUser(username, password, clientid) {
    console.log(
        "user_script.js: username: " +
            username +
            ", password: " +
            password +
            ", clientid: " +
            clientid
    );

    // if any of the parameters are empty, return false
    if (username == "" || password == "" || clientid == "") {
        return false;
    }

    // check bridge username and password use-case
    if (username === bridge_username && password === bridge_password) {
        console.log("Allowing bridge connection");
        return true;
    }

    // if clientid is not the same as username, ensure username is N0CALL
    if (clientid !== username) {
        // check that username is not the same as clientid
        if (username !== "N0CALL") {
            console.log("Invalid username: " + username);
            return false;
        } else {
            // user is connecting with N0CALL and random clientid, so allow read-only connection with "-1" password
            if (password === "-1") {
                console.log("Allowing read-only connection with N0CALL");
                return true;
            } else {
                console.log("Invalid password for read-only connection: " + password);
                return false;
            }
        }
    }

    // not a read-only connection (since clientid == username), so validate that ham callsign passcode is correct

    // check that password matches the one generated by the passcode function
    try {
        correctPasscode = passcode(username);
        return password === correctPasscode.toString();
    } catch (error) {
        console.error("Error generating passcode: ", error);
        return false;
    }
}

checkUser(username, password, clientid);
